import { globby } from 'globby';
import path from 'path';
import fs from 'fs';
import { getFileHeader } from './file-header.js';

const head = getFileHeader();

export async function resetDirectory(directory) {
  const files = await globby(directory + '/(.github|.husky|.vscode|docs|scripts|src)/**/*.*'); // adjust the pattern as needed

  for (const file of files) {
    const content = fs.readFileSync(file, 'utf8');
    if (content.startsWith(head)) {
      fs.unlinkSync(file);
      let currentDir = path.dirname(file);
      while (currentDir !== directory) {
        if (fs.readdirSync(currentDir).length === 0) {
          fs.rmdirSync(currentDir);
          currentDir = path.dirname(currentDir);
        } else {
          break;
        }
      }
    }
  }
}

/**
 * 
 * @param {*} sourceDir 
 * @param {*} targetDir 
 * @param {*} component 
 * @returns {Promise<string[]>} List of overriden files
 */

export async function createFiles(sourceDir, targetDir, component) {
  const files = await globby(path.join(sourceDir, component).replace(/\\/g, "/"));

  let overriden = [];
  for (const sourceFile of files) {
    const relativePath = path.relative(path.join(sourceDir, component), sourceFile);
    const targetPath = path.join(targetDir, component, relativePath);

    // Check if target file already exists
    if (fs.existsSync(targetPath)) {
      continue; // skip copying
    }

    // Read source content, prepend header, and write to target
    const content = fs.readFileSync(sourceFile, 'utf8');
    const autoGeneratedContent = head + content;

    fs.mkdirSync(path.dirname(targetPath), { recursive: true });
    fs.writeFileSync(targetPath, autoGeneratedContent, 'utf8');

    overriden.push(targetPath.replace(/\\/g, "/"));
  }
  return overriden;
}



