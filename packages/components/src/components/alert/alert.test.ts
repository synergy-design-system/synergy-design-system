/**
 * ---------------------------------------------------------------------
 * ðŸ”’ AUTOGENERATED BY VENDORISM
 * Removing this comment will prevent it from being managed by it.
 * ---------------------------------------------------------------------
 */

/* eslint-disable */
import '../../../dist/synergy.js';
import { aTimeout, expect, fixture, html, oneEvent } from '@open-wc/testing';
import { clickOnElement, moveMouseOnElement } from '../../internal/test.js';
import { queryByTestId } from '../../internal/test/data-testid-helpers.js';
import { resetMouse } from '@web/test-runner-commands';
import sinon from 'sinon';
import type SynAlert from './alert.js';
import type SynIconButton from '../icon-button/icon-button.js';

const getAlertContainer = (alert: SynAlert): HTMLElement => {
  return alert.shadowRoot!.querySelector<HTMLElement>('[part="base"]')!;
};

const expectAlertToBeVisible = (alert: SynAlert): void => {
  const alertContainer = getAlertContainer(alert);
  const style = window.getComputedStyle(alertContainer);
  expect(style.display).not.to.equal('none');
  expect(style.visibility).not.to.equal('hidden');
  expect(style.visibility).not.to.equal('collapse');
};

const expectAlertToBeInvisible = (alert: SynAlert): void => {
  const alertContainer = getAlertContainer(alert);
  const style = window.getComputedStyle(alertContainer);
  expect(style.display, 'alert should be invisible').to.equal('none');
};

const expectHideAndAfterHideToBeEmittedInCorrectOrder = async (alert: SynAlert, action: () => void | Promise<void>) => {
  const hidePromise = oneEvent(alert, 'syn-hide');
  const afterHidePromise = oneEvent(alert, 'syn-after-hide');
  let afterHideHappened = false;
  oneEvent(alert, 'syn-after-hide').then(() => (afterHideHappened = true));

  action();

  await hidePromise;
  expect(afterHideHappened).to.be.false;

  await afterHidePromise;
  expectAlertToBeInvisible(alert);
};

const expectShowAndAfterShowToBeEmittedInCorrectOrder = async (alert: SynAlert, action: () => void | Promise<void>) => {
  const showPromise = oneEvent(alert, 'syn-show');
  const afterShowPromise = oneEvent(alert, 'syn-after-show');
  let afterShowHappened = false;
  oneEvent(alert, 'syn-after-show').then(() => (afterShowHappened = true));

  action();

  await showPromise;
  expect(afterShowHappened).to.be.false;

  await afterShowPromise;
  expectAlertToBeVisible(alert);
};

const getCloseButton = (alert: SynAlert): SynIconButton | null | undefined =>
  alert.shadowRoot?.querySelector<SynIconButton>('[part="close-button"]');

describe('<syn-alert>', () => {
  let clock: sinon.SinonFakeTimers | null = null;

  afterEach(async () => {
    clock?.restore();
    await resetMouse();
  });

  it('renders', async () => {
    const alert = await fixture<SynAlert>(html`<syn-alert open>I am an alert</syn-alert>`);

    expectAlertToBeVisible(alert);
  });

  it('is accessible', async () => {
    const alert = await fixture<SynAlert>(html`<syn-alert open>I am an alert</syn-alert>`);

    await expect(alert).to.be.accessible();
  });

  describe('alert visibility', () => {
    it('should be visible with the open attribute', async () => {
      const alert = await fixture<SynAlert>(html`<syn-alert open>I am an alert</syn-alert>`);

      expectAlertToBeVisible(alert);
    });

    it('should not be visible without the open attribute', async () => {
      const alert = await fixture<SynAlert>(html` <syn-alert>I am an alert</syn-alert>`);

      expectAlertToBeInvisible(alert);
    });

    it('should emit syn-show and syn-after-show when calling show()', async () => {
      const alert = await fixture<SynAlert>(html` <syn-alert>I am an alert</syn-alert>`);

      expectAlertToBeInvisible(alert);

      await expectShowAndAfterShowToBeEmittedInCorrectOrder(alert, () => alert.show());
    });

    it('should emit syn-hide and syn-after-hide when calling hide()', async () => {
      const alert = await fixture<SynAlert>(html` <syn-alert open>I am an alert</syn-alert>`);

      await expectHideAndAfterHideToBeEmittedInCorrectOrder(alert, () => alert.hide());
    });

    it('should emit syn-show and syn-after-show when setting open = true', async () => {
      const alert = await fixture<SynAlert>(html` <syn-alert>I am an alert</syn-alert> `);

      await expectShowAndAfterShowToBeEmittedInCorrectOrder(alert, () => {
        alert.open = true;
      });
    });

    it('should emit syn-hide and syn-after-hide when setting open = false', async () => {
      const alert = await fixture<SynAlert>(html` <syn-alert open>I am an alert</syn-alert> `);

      await expectHideAndAfterHideToBeEmittedInCorrectOrder(alert, () => {
        alert.open = false;
      });
    });
  });

  describe('close button', () => {
    it('shows a close button if the alert has the closable attribute', async () => {
      const alert = await fixture<SynAlert>(html` <syn-alert open closable>I am an alert</syn-alert> `);
      const closeButton = getCloseButton(alert);

      expect(closeButton).to.be.visible;
    });

    it('clicking the close button closes the alert', async () => {
      const alert = await fixture<SynAlert>(html` <syn-alert open closable>I am an alert</syn-alert> `);
      const closeButton = getCloseButton(alert);

      await expectHideAndAfterHideToBeEmittedInCorrectOrder(alert, () => {
        clickOnElement(closeButton!);
      });
    });

    it('clicking above close button does not close the alert', async () => {
      const wrapper = await fixture<HTMLDivElement>(
        html`<div class="wrapper" style="padding: 24px; background-color:red;">
          <syn-alert open closable>I am an alert</syn-alert>
        </div>`
      );
      const alert = wrapper.querySelector('syn-alert')!;

      const clickTargetPromise = new Promise<HTMLElement>(resolve => {
        const clickHandler = sinon.spy((event: MouseEvent) => {
          resolve(event.target as HTMLElement);
        });
        alert.shadowRoot!.addEventListener('click', clickHandler);
        wrapper.addEventListener('click', clickHandler);
      });

      const closeButton = getCloseButton(alert);
      await clickOnElement(closeButton!, 'top', 0, -4);
      const clickTarget = await clickTargetPromise;
      await expect(clickTarget.tagName.toLowerCase()).to.not.be.equal('syn-icon-button');
      expect(clickTarget.classList.contains('alert')).to.be.true;
      expect(clickTarget.classList.contains('wrapper'), 'The click should happen in the alert and not outside of it').to
        .be.false;
    });

    it('clicking under close button does not close the alert', async () => {
      const wrapper = await fixture<HTMLDivElement>(
        html`<div class="wrapper" style="padding: 24px; background-color:red;">
          <syn-alert open closable>I am an alert</syn-alert>
        </div>`
      );
      const alert = wrapper.querySelector('syn-alert')!;

      const clickTargetPromise = new Promise<HTMLElement>(resolve => {
        const clickHandler = sinon.spy((event: MouseEvent) => {
          resolve(event.target as HTMLElement);
        });
        alert.shadowRoot!.addEventListener('click', clickHandler);
        wrapper.addEventListener('click', clickHandler);
      });

      const closeButton = getCloseButton(alert);
      await clickOnElement(closeButton!, 'bottom', 0, 4);
      const clickTarget = await clickTargetPromise;

      await expect(clickTarget.tagName.toLowerCase()).to.not.be.equal('syn-icon-button');
      expect(clickTarget.classList.contains('alert')).to.be.true;
      expect(clickTarget.classList.contains('wrapper'), 'The click should happen in the alert and not outside of it').to
        .be.false;
    });

    it('clicking on the right side of the close button does not close the alert', async () => {
      const wrapper = await fixture<HTMLDivElement>(
        html`<div class="wrapper" style="padding: 24px; background-color:red;">
          <syn-alert open closable>I am an alert</syn-alert>
        </div>`
      );
      const alert = wrapper.querySelector('syn-alert')!;

      const clickTargetPromise = new Promise<HTMLElement>(resolve => {
        const clickHandler = sinon.spy((event: MouseEvent) => {
          resolve(event.target as HTMLElement);
        });
        alert.shadowRoot!.addEventListener('click', clickHandler);
        wrapper.addEventListener('click', clickHandler);
      });

      const closeButton = getCloseButton(alert);
      await clickOnElement(closeButton!, 'right', 4, 0);
      const clickTarget = await clickTargetPromise;

      await expect(clickTarget.tagName.toLowerCase()).to.not.be.equal('syn-icon-button');
      expect(clickTarget.classList.contains('alert')).to.be.true;
      expect(clickTarget.classList.contains('wrapper'), 'The click should happen in the alert and not outside of it').to
        .be.false;
    });
  });

  describe('toast', () => {
    const getToastStack = (): HTMLDivElement | null => document.querySelector<HTMLDivElement>('.syn-toast-stack');

    const closeRemainingAlerts = async (): Promise<void> => {
      const toastStack = getToastStack();
      if (toastStack?.children) {
        for (const element of toastStack.children) {
          await (element as SynAlert).hide();
        }
      }
    };

    beforeEach(async () => {
      await closeRemainingAlerts();
    });

    it('can be rendered as a toast', async () => {
      const alert = await fixture<SynAlert>(html`<syn-alert>I am an alert</syn-alert>`);

      expectShowAndAfterShowToBeEmittedInCorrectOrder(alert, () => alert.toast());
      const toastStack = getToastStack();
      expect(toastStack).to.be.visible;
      expect(toastStack?.firstChild).to.be.equal(alert);
    });

    it('resolves only after being closed', async () => {
      const alert = await fixture<SynAlert>(html`<syn-alert closable>I am an alert</syn-alert>`);

      const afterShowEvent = oneEvent(alert, 'syn-after-show');
      let toastPromiseResolved = false;
      alert.toast().then(() => (toastPromiseResolved = true));

      await afterShowEvent;
      expect(toastPromiseResolved).to.be.false;

      const closePromise = oneEvent(alert, 'syn-after-hide');
      const closeButton = getCloseButton(alert);
      clickOnElement(closeButton!);

      await closePromise;
      await aTimeout(0);

      expect(toastPromiseResolved).to.be.true;
    });

    const expectToastStack = () => {
      const toastStack = getToastStack();
      expect(toastStack).not.to.be.null;
    };

    const expectNoToastStack = () => {
      const toastStack = getToastStack();
      expect(toastStack).to.be.null;
    };

    const openToast = async (alert: SynAlert): Promise<void> => {
      const openPromise = oneEvent(alert, 'syn-after-show');
      alert.toast();
      await openPromise;
    };

    const closeToast = async (alert: SynAlert): Promise<void> => {
      const closePromise = oneEvent(alert, 'syn-after-hide');
      const closeButton = getCloseButton(alert);
      await clickOnElement(closeButton!);
      await closePromise;
      await aTimeout(0);
    };

    it('deletes the toast stack after the last alert is done', async () => {
      const container = await fixture<HTMLElement>(
        html`<div>
          <syn-alert data-testid="alert1" closable>alert 1</syn-alert>
          <syn-alert data-testid="alert2" closable>alert 2</syn-alert>
        </div>`
      );

      const alert1 = queryByTestId<SynAlert>(container, 'alert1');
      const alert2 = queryByTestId<SynAlert>(container, 'alert2');

      await openToast(alert1!);

      expectToastStack();

      await openToast(alert2!);

      expectToastStack();

      await closeToast(alert1!);

      expectToastStack();

      await closeToast(alert2!);

      expectNoToastStack();
    });
  });

  describe('timer controlled closing', () => {
    it('closes after a predefined amount of time', async () => {
      clock = sinon.useFakeTimers();
      const alert = await fixture<SynAlert>(html` <syn-alert open duration="3000">I am an alert</syn-alert>`);

      expectAlertToBeVisible(alert);

      clock.tick(2999);

      expectAlertToBeVisible(alert);

      await expectHideAndAfterHideToBeEmittedInCorrectOrder(alert, () => {
        clock?.tick(1);
      });
    });

    it('resets the closing timer after mouse-over', async () => {
      clock = sinon.useFakeTimers();
      const alert = await fixture<SynAlert>(html` <syn-alert open duration="3000">I am an alert</syn-alert>`);

      expectAlertToBeVisible(alert);

      clock.tick(1000);

      await moveMouseOnElement(alert);

      clock.tick(2999);

      expectAlertToBeVisible(alert);

      await expectHideAndAfterHideToBeEmittedInCorrectOrder(alert, () => {
        clock?.tick(1);
      });
    });

    it('resets the closing timer after opening', async () => {
      clock = sinon.useFakeTimers();
      const alert = await fixture<SynAlert>(html` <syn-alert duration="3000">I am an alert</syn-alert>`);

      expectAlertToBeInvisible(alert);

      clock.tick(1000);

      const afterShowPromise = oneEvent(alert, 'syn-after-show');
      alert.show();
      await afterShowPromise;

      clock.tick(2999);

      await expectHideAndAfterHideToBeEmittedInCorrectOrder(alert, () => {
        clock?.tick(1);
      });
    });
  });

  describe('alert variants', () => {
    const variants = ['primary', 'success', 'neutral', 'warning', 'danger'];

    variants.forEach(variant => {
      it(`adapts to the variant: ${variant}`, async () => {
        const alert = await fixture<SynAlert>(html`<syn-alert variant="${variant}" open>I am an alert</syn-alert>`);

        const alertContainer = getAlertContainer(alert);
        expect(alertContainer).to.have.class(`alert--${variant}`);
      });
    });
  });
});
